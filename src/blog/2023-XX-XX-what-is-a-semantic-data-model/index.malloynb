>>>markdown
# What is a Semantic Data Model?   

Let’s start simply.  Define: *dimension*, *measure*, *aggregating query*, *lookup query*.   

## Data for Kindergarteners
Given that we learn about data in Kindergarten, It is really surprising how hard it is to query data in the "big" world.  In kindergarten data we notice attributes about things, make piles of things, and count things in the piles.  We do this even before we learn any "real" math.  Strangely, noticing attributes about *things* and counting *things* is almost all there is to working with data.

Two types of queries, "Where's Waldo" and "Making Piles"
There are really two types of queries in the world, lookup and aggregating. 

*Lookup* queries are pretty easy.  Google search is a lookup query.  To search, type in some terms then see a list of results. Searching in SQL this often looks like `SELECT * FROM <something> WHERE <FILTER>``.

The interesting queries, the kindergarten queries, are *aggregating*.  Aggregating queries tell you something about a set of data.  An aggregating query has two main parts, the dimensions and measures.

Dimensions are the attribute you use to decide which pile the thing goes in.

A measure is something you can say about the pile.  "How many objects?", "How much does this pile weigh?", "What is the average size of an object in this pile?". 

"Ok class let's take this pile of coins and separate them.  How many coins are pennies?  How many coins are nickels? Dimes?  Quarters?"

Aggregating queries  tell us things about  datasets.  Lookup queries find things.

## SQL World

In the SQL world, the interface to your data is just that, data.  The data sits in tables.  Working with data means defining a query and in that query describing how to group by (make piles) and how to aggregate.  The calculations for all of this are repeated every time you ask a question.

## The Semantic Data Model is the interface to your data
In a Semantic Data Model, the calculations for measures, join relationships and the common ways of looking at data are coded.  The act of querying becomes simply picking dimensions and measure, filtering the input and output data and sorting the results.  The simplification is powerful in that the measuring calculations are always vetted and that it becomes much harder to get incorrect results.  

## A Simple Example
Below is a semantic data model for some flight data.   Each flight has an origin, destination and carrier.  Flights can be delayed.  Each flight has an aircraft that made the flight and more.  The Semantic data model provided us with the dimension (in blue) and the measures and  graph of the related objects.  This model is encoded in a file called ‘flights.malloy’.  
>>>malloy
##! experimental.scalar_lenses
import {flights} from 'flights.malloy' 
>>>markdown
<img src="schema.png">
>>>markdown
##  First query: How big is the pile?
Often, the first thing you want to know is, how big is the dataset?  
>>>malloy
run: flights-> flight_count
>>>markdown
### How it works.

In Malloy, queries start with `run: <source>`.  In this case, flights.  The `->` is the query transform operator.  The right hand side of the `->` is the query transformation.  In this case we want a simple measure, flight_count.

## Dimensions and Measures
As we talked about earlier.  Aggregating queries have two parts what you want to group by and what you want to measure about things in that group.  Let's group the flights by the origin and count how many flights.  When building a query, we use the `+` operator to combine the parts.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> origin_name + flight_count 
>>>markdown
## Shorthand and Seats
Another way of measuring how busy an airport is to try and estimate the number of people that travel through the airport.  Planes are of different sizes.  If we count up all the seats in all the planes that have arrived we can approximate the busyness.  The measure `seats_for_sale` will give us the maximum number of people that could have landed there.  

Notice Chicago has more people traveling through than Dallas-Fort Worth.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> origin_name + seats_for_sale + flight_count
>>>markdown
## Filtering
Isolating the data to analyze is a big part of working with data.  Let's limit our analysis to California airports.  We've reformated the query.  In Malloy, spaces and new lines are the same thing.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> 
  origin_name 
  + seats_for_sale
  + flight_count
  + {where: origin.state='CA'}
>>>markdown
## Adding your own measures
The Malloy Semantic data model provides most of what we would like to calculate but we can provide our own calculations in our queries.  This model doesn't contain an `average_distance`.  We can compute this ourselves.

It looks like Jetblue, on average, has the longest flights.

You may also noticed that by default, Malloy sorts results by the first measure descending.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> 
  carrier_name
  + {aggregate: avg_distance is distance.avg()}
  + flight_count 
>>>markdown
### Changing the sort order
We can change the sort order by adding a `{order_by: }` clause
>>>malloy
#(docs) limit=5000 size=small
run: flights -> 
  carrier_name
  + {aggregate: avg_distance is distance.avg()}
  + flight_count 
  + {order_by: flight_count desc}
>>>markdown
## Adding your own dimensions
You can group by an expression.  The expressions can contain just about any calculation you can do in SQL.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> 
  {group_by: carrier is concat(carrier, ' - ', carrier_name)}
  + origin_count
  + flight_count
  
>>>markdown
## Working with Time
A big part of working with data is working with time.  Queries that have time in the first column are sorted by time descending.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> 
  {group_by: flight_month is dep_time.month}
  + flight_count
  + {where: carrier = 'WN'}
>>>markdown
## Annotations and Charting
Charts are generally another view on tables.  For example, the table above can be viewed as a line chart.  The x-axis is `flight_month` and the y-axis would be `flight_count`.  Malloy's annotations let you tag a query so the rendering engine can show the results in different ways.  We simply tag the query above as a `# line_chart`.
>>>malloy
#(docs) limit=5000 size=large
# line_chart
run: flights -> 
  {group_by: flight_month is dep_time.month}
  + flight_count
  + {where: carrier = 'WN'}
>>>markdown
## Filtering Time
Filtering time ranges is always difficult in SQL.  Malloy time ranges can be specified simply.  We add a filter to filter the time range to the year 2001.
>>>malloy
#(docs) limit=5000 size=large
# line_chart
run: flights -> 
  {group_by: flight_month is dep_time.month}
  + flight_count
  + carrier_name
  + {where: dep_time ? @2001}
>>>markdown
## Views: Pre-built Queries
Semantic models can include views.  Views are pre-built queries.  Often in a dataset there are several interesting ways of looking at the dataset.  A common use for views is to declare these in advance.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> by_carrier
>>>markdown
## Convention the 'metrics' view.
Malloy models often contain a `metrics` view.  The metrics view contains just measures contains the common ways of measuring data in this data set.  The metrics view makes it easy build queries on the fly.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> metrics
>>>markdown
## Metrics by Origin
Views can be combined in queries just like all the other parts.
>>>malloy
#(docs) limit=5000 size=small
run: flights -> origin_name + metrics
>>>markdown
## Metric by Manufacturer
>>>malloy
#(docs) limit=5000 size=small
run: flights -> plane_manufacturer + metrics
>>>markdown
## Nesting
One of the really powerful features of the Malloy language is nesting.  We can see which carriers fly which airplanes.
>>>malloy
#(docs) limit=5000 size=large
run: flights -> plane_manufacturer + metrics + {
  nest: carrier_name + aircraft_count
}
>>>markdown
## Nesting multiple queries
More than one query can be nested.
>>>malloy
#(docs) limit=5000 size=large
run: flights -> by_carrier + {
  nest: plane_manufacturer + metrics
  nest: origin_name + metrics + {limit: 5}
}