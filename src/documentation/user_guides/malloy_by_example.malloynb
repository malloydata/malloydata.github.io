>>>markdown
# Advanced Modeling

This guide covers advanced Malloy features for building sophisticated semantic models. It assumes you've completed [Building a Semantic Model](quickstart_modeling.malloynb) and are familiar with sources, dimensions, measures, views, and basic joins.

---

## Setup

The examples below use these source definitions:
>>>malloy
source: airports is duckdb.table('../data/airports.parquet') extend {
  measure: airport_count is count()
  measure: avg_elevation is elevation.avg()

  view: by_state is {
    group_by: state
    aggregate: airport_count
  }

  view: top_5_states is {
    group_by: state
    aggregate: airport_count
    limit: 5
  }

  view: by_facility_type is {
    group_by: fac_type
    aggregate: airport_count
  }
}
>>>markdown

---

## Nesting Queries

The `nest:` property embeds one query inside another, creating subtables within your results. This is powerful for understanding data hierarchically.

### Basic Nesting

Group by state, then nest facility types within each state:
>>>malloy
run: airports -> {
  group_by: state
  aggregate: airport_count
  limit: 5
  nest: by_facility_type is {
    group_by: fac_type
    aggregate: airport_count
  }
}
>>>markdown

### Multiple Nested Views

Queries can contain multiple nested views:
>>>malloy
run: airports -> {
  group_by: faa_region
  aggregate: airport_count
  nest: top_5_states
  nest: by_facility_type
}
>>>markdown

### Deep Nesting

Views can be nested to any depth:
>>>malloy
run: airports -> {
  group_by: faa_region
  aggregate: airport_count
  nest: by_state_and_county is {
    group_by: state
    aggregate: airport_count
    nest: by_county is {
      group_by: county
      aggregate: airport_count
      limit: 4
    }
  }
  nest: by_facility_type
}
>>>markdown

See [Nested Views](../language/nesting.malloynb) for more details.

---

## Refining Views

The `+ { }` gesture lets you extend an existing view with additional query terms.

### Add Ordering and Limits
>>>malloy
run: airports -> by_state + {
  order_by: state desc
  limit: 3
}
>>>markdown

### Add Measures
>>>malloy
run: airports -> by_facility_type + {
  aggregate: avg_elevation
}
>>>markdown

### Add Nested Views
>>>malloy
run: airports -> top_5_states + {
  nest: by_facility_type
}
>>>markdown

Swapping inner and outer reveals different insights:
>>>malloy
run: airports -> by_facility_type + {
  nest: top_5_states
}
>>>markdown

---

## Aggregates Across the Join Tree

Malloy computes aggregates correctly at any node in a join graph—something difficult in SQL.

### Setup: Multi-level Joins
>>>malloy
source: carriers2 is duckdb.table('../data/carriers.parquet') extend {
  primary_key: code
  measure: carrier_count is count()
}

source: flights2 is duckdb.table('../data/flights.parquet') extend {
  join_one: carriers2 with carrier

  measure:
    flight_count is count()
    total_distance is distance.sum()
    avg_distance is distance.avg()
}

source: airports2 is duckdb.table('../data/airports.parquet') extend {
  join_many: flights2 on code = flights2.origin

  measure: airport_count is count()
  measure: avg_elevation is elevation.avg()
}
>>>markdown

### Aggregate at Any Level

This query aggregates across three levels of joins—something very difficult in SQL:
>>>malloy
run: airports2 -> {
  group_by: state
  aggregate:
    flights2.carriers2.carrier_count  // 3 levels deep
    flights2.flight_count
    flights2.total_distance
    airport_count
    avg_elevation
}
>>>markdown

See [Aggregates](../language/aggregates.malloynb) for details on symmetric aggregates.

---

## Pipelines

Chain queries together—the output of one becomes the input of the next.

### Basic Pipeline

First, a nested query:
>>>malloy
source: airports3 is duckdb.table('../data/airports.parquet') extend {
  measure: airport_count is count()
}

run: airports3 -> {
  where: fac_type = 'HELIPORT'
  group_by: state
  aggregate: airport_count
  nest: top_3_county is {
    limit: 3
    group_by: county
    aggregate: airport_count
  }
}
>>>markdown

### Un-nesting with a Pipeline

Chain another query to flatten the nested results:
>>>malloy
run: airports3 -> {
  where: fac_type = 'HELIPORT'
  group_by: state
  aggregate: airport_count
  nest: top_3_county is {
    limit: 3
    group_by: county
    aggregate: airport_count
  }
} -> {
  select:
    state
    top_3_county.county
    airports_in_state is airport_count
    airports_in_county is top_3_county.airport_count
    percent_of_state is top_3_county.airport_count / airport_count
}
>>>markdown

### Pipelines as Views

Complex pipelines can be saved as views:
>>>malloy
source: airports4 is duckdb.table('../data/airports.parquet') extend {
  measure: airport_count is count()

  view: county_rollup is {
    where: fac_type = 'HELIPORT'
    group_by: state
    aggregate: airport_count
    nest: top_3_county is {
      limit: 3
      group_by: county
      aggregate: airport_count
    }
  } -> {
    select:
      state
      top_3_county.county
      airports_in_state is airport_count
      airports_in_county is top_3_county.airport_count
      percent_of_state is top_3_county.airport_count / airport_count
  }
}

run: airports4 -> county_rollup
>>>markdown

---

## Extending Sources

Create new sources based on existing ones with `extend`:

```malloy
source: california_airports is airports extend {
  where: state = 'CA'
  measure: ca_airport_count is count()
}
```

The new source inherits all fields from the original and adds new constraints or calculations.

---

## Sources Based on Queries

Pre-process data with a query, then build a source on top of it.

### Define a Model-Level Query
>>>malloy
query: airport_facts_query is duckdb.table('../data/flights.parquet') -> {
  group_by:
    flight_year is dep_time.year
    origin
    carrier
  aggregate:
    num_flights is count()
    total_distance is distance.sum()
}

run: airport_facts_query
>>>markdown

### Build a Source on the Query
>>>malloy
source: airport_facts is airport_facts_query extend {
  measure: flight_count is num_flights.sum()
  measure: distance is total_distance.sum()

  view: by_year is {
    group_by: flight_year
    aggregate:
      flight_count
      carrier_count is count(carrier)
      origin_count is count(origin)
  }

  view: by_origin is {
    group_by: origin
    aggregate:
      flight_count
      carrier_count is count(carrier)
  }
}

run: airport_facts -> by_origin
>>>markdown

---

## Learn More

- [Nested Views](../language/nesting.malloynb) - Full nesting documentation
- [Aggregates](../language/aggregates.malloynb) - Symmetric aggregates and locality
- [Views](../language/views.malloynb) - View patterns and refinement
- [Sources](../language/source.malloynb) - Source types and extensions
